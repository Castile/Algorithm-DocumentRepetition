A recursive algorithm is one that invokes makes reference to itself repeatedly until a certain condition also known as termination condition matches, which is a method common to functional programming. Iterative algorithms use repetitive constructs like loops and sometimes additional data structures like stacks to solve the given problems. Some problems are naturally suited for one implementation or the other. In mathematics and computer science, an algorithm is a self contained step by step set of operations to be performed. Algorithm versus function computable by an algorithm, For a given function multiple algorithms may exist. Algorithms exist that perform calculation, data processing, and automated reasoning. Does an algorithm do what its author wants it to do? A few test cases usually suffice to confirm core functionality. Starting from an initial state and initial input, when executed, proceeds through a finite number of well defined successive states, eventually producing output and terminating at a final ending state. The transition from one state to not necessarily deterministic, some algorithms, known as randomized algorithms, incorporate random input. Algorithms can be expressed in many kinds of notation, including natural languages, flowcharts, charts, programming languages or control tables. Natural language algorithms tend to be verbose and ambiguous, and are rarely used for complex or algorithms. Another way of classifying algorithms is by their design methodology or paradigm. There is a certain number of paradigms, each different from the other. Furthermore, each of these categories include many different types of algorithms. Pseudocode, flowcharts, drakon charts and control tables are structured ways to express algorithms that avoid many of the ambiguities common in natural language statements. A divide and conquer algorithm repeatedly reduces an instance of a problem to one or smaller instances of the same problem, usually recursively until the instances are small enough to solve easily. One such example of divide and conquer is merge sorting. Sorting can be done on each segment of data after dividing data into segments and sorting of entire data can be obtained in the conquer phase by merging the segments. A simpler variant of divide and conquer is called a decrease and conquer algorithm, that solves an identical sub problem and uses the solution of this sub problem to solve the bigger problem. Divide and conquer divides the problem into multiple sub problems and so the conquer stage is more complex than decrease and conquer algorithms. An example of decrease and conquer algorithm is the binary search algorithm. There is a wide variety of representations possible and one can express a given Turing machine program as a sequence of machine tables, see more at finite state machine, many state transition table and control book table, as flowcharts and drakon charts, see more at state diagram, rudimentary machine code or assembly code called sets of quadruples. Many problems such as playing chess can be modeled as problems on graphs. A graph exploration algorithm specifies rules for moving around a graph and is useful for such problems. This category also includes search algorithms, branch and bound enumeration and backtracking. In computer systems, an algorithm is basically an instance of logic written in software by software developers to be effective for the intended target computer to produce output from given input. An optimal efficient algorithm, even running in very good hardware, would produce faster results than a non optimal algorithm for the same purpose, running in more efficient hardware, like computer hardware, are considered technology. This technique involves solving a difficult problem by transforming it into a better known problem for which we have hopefully asymptotically optimal algorithms. The goal is to find a reducing algorithm whose complexity is not dominated by the resulting reduced algorithm. For example, one selection algorithm for finding the median in an unsorted list involves first sorting the list the expensive portion and then pulling out the middle element in the sorted list. This technique is also known as transform and conquer.
